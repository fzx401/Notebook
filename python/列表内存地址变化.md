# Python中list数据结构的内存地址变化

:zap:**list中各元素实际上存放的是指向内存中实际数据的引用**

* Python中一切数据结构都是对象，一个list也是一个object
* 当我们创建了一个list：
  ```
  a = [1, 2, 3]
  ```
* a有三个元素，a[0] a[1] a[2]
  :exclamation:注意，是a[0] a[1] a[2]而不是整数1、2、3
  :point_right:a[0] a[1] a[2]三个引用分别指向内存中真正存储1、2、3三个整数的地址
  :point_right:a作为一个list object，本身也有一个地址：
    ```
    print(f'列表a的地址:{id(a)}')
    print(f'第一个元素地址:{id(a[0])}')
    print(f'第二个元素地址:{id(a[1])}')
    print(f'第三个元素地址:{id(a[2])}')

    列表a的地址:4378352448
    第一个元素地址:4310597872
    第二个元素地址:4310597904
    第三个元素地址:4310597936
    ```
* 当对a的元素进行赋值修改或者计算修改时，例如：
  ```
    a[0] = 3
    print(f'列表a的地址:{id(a)}')
    print(f'第一个元素地址:{id(a[0])}')
    print(f'第二个元素地址:{id(a[1])}')
    print(f'第三个元素地址:{id(a[2])}')
  ```
  :thumbsup:可以看到，只对列表中某个元素进行赋值改变，相当于a[0]这个引用/变量不变，只是让他指向另一块新的数值地址(这个元素地址为原地址+(新数值-旧数值)*32(int类型下))
  :point_right:因此a[0]本身的地址变了，但是a作为一个list object本身还是原来的list object，故a的地址未变

* 当对a的元素进行直接计算操作时，例如：
    ```
    a[1] += 3
    print(f'列表a的地址:{id(a)}')
    print(f'第一个元素地址:{id(a[0])}')
    print(f'第二个元素地址:{id(a[1])}')
    print(f'第三个元素地址:{id(a[2])}')
    列表a的地址:4378352448
    第一个元素地址:4310597936
    第二个元素地址:4310598416
    第三个元素地址:4310597936
    ```
    :heavy_check_mark:同样没有发生变化，但是对list object本身进行切片、复制则会生成新的list object，此时地址会变化：
    ```
    a = a[:]
    print(f'列表a的地址:{id(a)}')
    print(f'第一个元素地址:{id(a[0])}')
    print(f'第二个元素地址:{id(a[1])}')
    print(f'第三个元素地址:{id(a[2])}')
    列表a的地址:4375572608
    第一个元素地址:4310597936
    第二个元素地址:4310598416
    第三个元素地址:4310597936
    ```
    :flushed:但是可以看到，由于list中每个元素是一个引用，指向一个固定的地址，所以哪怕这时候a变了，但是a中的元素居然相对“独立”地没有发生任何变化
    